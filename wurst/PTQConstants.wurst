package PTQConstants
import SoundUtils
import Simulate3dSound
import LinkedList
import Item
import TimerUtils
public constant CROW_FORM = 'Amrf'
public constant LOCUST = 'Aloc'
public constant player GoodGusy = Player(10)
public constant player BadGuy = Player(11)
item posTestItem = createItem('odef', vec2(0,0))

public function getComputerAlly(player p) returns player
    player result = BadGuy
    if(p.isAllyOf(GoodGusy))
        result = GoodGusy
    return result

public function getHumanPlayers()
    
interface PredicateClosure
    function test(unit u) returns boolean
public function getUnitsInRangeOfLocMatchingClosure(real radius, vec2 pos, PredicateClosure closure) returns group
    group g = GetUnitsInRangeOfLocAll(radius, PTQUtils.vec2ToLoc(pos))
    for unit u in g
        if(not closure.test(u))
            g.removeUnit(u)
    destroy closure
    return g
public interface DelayedEffect
    function run()

public function vec2.testForPathability() returns boolean
    posTestItem.setPos(this)
    let res = posTestItem.getPos() == this
    posTestItem.setPos(vec2(0,0))
    return res
public class PTQUtils
        
    static function enableFlyingForUnit(unit u)
        u.addAbility(CROW_FORM)
        u.removeAbility(CROW_FORM)
    static function vec2ToLoc(vec2 vec) returns location
        return Location(vec.x, vec.y)
    static function makeUnitUnTargetable(unit u)
        u.addAbility(LOCUST)
    static function playLocalSound(SoundDefinition snd, vec2 pos, int recycleDuration) returns sound
        sound s = snd.play(recycleDuration).snd
        bindSoundToPoint(s, pos.x, pos.y, 400,800, 15000)
        return s
    static function delayedEffect(real delay, DelayedEffect eff)
        timer t = getTimer()
        t.setData(eff castTo int)
        t.start(delay, () -> (begin
            DelayedEffect sa = (GetExpiredTimer().getData() castTo DelayedEffect)
            GetExpiredTimer().destr()
        end))

init