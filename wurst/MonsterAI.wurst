package MonsterAI
import BasicAI
import PTQConstants
import CustomUnits
import DummyCaster
import Assets
import CustomAbilities
import ClosureEvents
import TimerUtils
import LinkedList
import GameTimer
import ClosureTimers
import TerrainUtils
import OrderIds
public class DethNightAI extends AbstractAIHandler
    construct(unit u)
        super(u)
    override function onDiffHP(real diff)
        if(diff < 0)
            flee()
    function flee()
        if(getTimeSinceLastOrder() > 5)
            vec2 fleeDest = u.getPos().polarOffset(u.getFacingAngle() + angle(PI), 600)
            u.issuePointOrder("move", fleeDest)
            trackOrderTime()

public class CrabAI extends AbstractAIHandler
    construct(unit u)
        super(u)
    override function onDiffHP(real diff)
        if(diff < 0 and getTimeSinceLastOrder() > 5)
            u.issueImmediateOrderById(OrderIds.waterelemental)
            trackOrderTime()

public class CryptFrendAI extends AbstractAIHandler
    construct(unit u)
        super(u)
    override function onDiffHP(real diff)
        if(u.getHP() < u.getMaxHP() * .5 and getTimeSinceLastOrder() > 1)
            attemptToGetHealed()
            trackOrderTime()

    function attemptToGetHealed()
        // find any DKs
        group dks = getUnitsInRangeOfLocMatchingClosure(2000, u.getPos()) (t) ->
            return t.getTypeId() == DETH_NIGHT and t.getOwner().isAllyOf(u.getOwner()) and t.isAliveTrick()

        if(dks.hasNext())
            unit dk = dks.next()
            dk.setFacing(dk.getPos().angleTo(u.getPos()))
            dk.setAnimation("Spell")
            new DummyCaster()
                ..origin(dk.getPos())
                ..owner(dk.getOwner())
                ..castTarget(skillCoilEffect, 1, OrderIds.deathcoil, u)
            
        dks.destr()

public class HarveyAI extends AbstractAIHandler
    unit gassyGnoll
    construct(unit u)
        super(u)

    override function onTick()
        super.onTick()
        if(getTimeSinceLastOrder() > 1 and gassyGnoll == null or getTimeSinceLastOrder() > 5) // more like gassy null amirite
            // find another gnoll if possible
            group g = getUnitsInRangeOfLocMatchingClosure(4000., u.getPos()) (unit test) ->
                return test.isAlive() and test.getTypeId() == GASSY_GNOLL and not u.getOwner().isEnemyOf(test.getOwner()) and test != gassyGnoll
            
            if(g.isEmpty())
                u.setFlyHeight(0, 0)
                u.disableAbility(ABILITY_GNOLL_EVASION, true, false)
            else
                unit bestUnit = null
                var dist = 0.0
                for unit test in g
                    let newDist =  bestUnit.getPos().distanceTo(u.getPos())
                    if(bestUnit == null or newDist > dist )
                        bestUnit = test
                        dist = newDist
                u.disableAbility(ABILITY_GNOLL_EVASION, false, false)
                u.setFlyHeight(50, 0)
                gassyGnoll = bestUnit
                flashEffect(Abilities.mirrorImageCaster, u, "chest")
            g.destr()
            trackOrderTime()
        if(gassyGnoll != null)
            u.setXY(gassyGnoll.getPos())




LinkedList<item> nearbyItems = new LinkedList<item>()
public class PoorSkeletonAI extends AbstractAIHandler
    item targetItem
    int gold
    int lvl = 1
    construct(unit u)
        super(u)
        EventListener.add(u, EVENT_PLAYER_UNIT_PICKUP_ITEM) () ->
            gold+= 250
            if(gold >= 500)
                upgradeBandit()
                checkForNearbyGold()
            

    ondestroy
        unregisterEventsForUnit(u)
    
    function goPickupItem()
        if(targetItem != null)
            trackOrderTime()
            u.issueTargetOrder("smart", targetItem)
        else
            u.issuePointOrder("attack", gg_rct_BanditCamp.getCenter())
    override function onTick()
    // TODO: If else logic may be incorrect
        if(targetItem != null)
            if(not targetItem.isAlive() or targetItem.getPos().distanceTo(u.getPos()) > 2000)
                targetItem = null
                checkForNearbyGold()
            else if(getTimeSinceLastOrder() > 5)
                goPickupItem()
        else if(targetItem == null and getTimeSinceLastOrder() > 2)
            checkForNearbyGold()
       

    function checkForNearbyGold()
        trackOrderTime()
        location l = u.getLoc()
        rect r = RectFromCenterSizeBJ(l, 900, 900)
        EnumItemsInRect(r, Condition(() -> begin
            return GetFilterItem().getTypeId() == 'gold'
        end)) () ->
            nearbyItems.add(GetEnumItem())
        if(not nearbyItems.isEmpty())
            targetItem = nearbyItems.getFirst()
            goPickupItem()
            nearbyItems.clear()
        else
            targetItem = null
            u.issuePointOrder("attack", gg_rct_BanditCamp.getCenter())

    function upgradeBandit()
        lvl++
        gold = 0
        switch(lvl)
            case 1
                u.setName("Poor Skeleton")
            case 2
                u.setName("Not quite so poor Skeleton")
            case 3
                u.setName("Getting back on his feet financially speaking Skeleton")
            case 4
                u.setName("Lower Middle Class Skeleton")
            case 5
                u.setName("Upper Middle Class Skeleton")
            case 6
                u.setName("Rich Skeleton")
            case 7
                u.setName("Filthy Rich Skeleton")
            case 8
                u.setName("The 1% Skeleton")
            case 9
                u.setName("Bill 'Boney' Gates")
            case 10
                u.setName("Jeff 'Probably Needs To Eat More' Bezos")
            case 11
                u.setName("Okay now you're just letting them get the gold")
            default
                u.setName("SSJ " + u.getLevel().toString() + " Rich Skeleton")
        let newHP = u.getMaxHP().toInt() * 1.3
        u.setMoveSpeed(u.getMoveSpeed() + 10)
        if(newHP < 500000000)
            u.setBaseDamage((u.getBaseDamage(0) * 1.5).toInt(), 0)
            u.setMaxHP(newHP.toInt())
            u.setHP(u.getMaxHP())
            u.setArmor(u.getArmor() + 1)
            u.setScale(1.0 + lvl / 5)
            flashEffect(Abilities.levelupcaster, u, "origin")



public class AeroBearAI extends AbstractAIHandler
    boolean doingRoll = false
    construct(unit u)
        super(u)

    override function onDiffHP(real diff)
        if(doingRoll)
            u.addHP(-diff)
            group g = getUnitsInRangeOfLocMatchingClosure(500, u.getPos()) (unit test) ->
                return test.isEnemyOf(u.getOwner()) and not test.isInvulnerable()
            for unit dmg in g
                u.damageTarget(dmg, -diff)
                flashEffect(Abilities.flyingMachineMissile, dmg, "chest")
            g.destr()
        else if(diff < 0 and getTimeSinceLastOrder() > 8)
            trackOrderTime()
            if(GetRandomReal(0, 1) > .5)
                bearelRoll()
            else
                bearCyclone() 

    function bearCyclone()
        u.setAnimation("Attack Slam")
        // SetTerrainType(u.getX(), u.getY(), 'Iice', 0, 2, 0)
        group g = getUnitsInRangeOfLocMatchingClosure(700, u.getPos()) (unit test) ->
            return test.isEnemyOf(u.getOwner()) and not test.isInvulnerable() and GetRandomReal(0, 1) > .5
        for unit dmg in g
            new DummyCaster()..owner(u.getOwner())
                ..origin(u.getPos())
                ..castTarget(bearCyclone, 1, OrderIds.cyclone, dmg)
    function bearelRoll()
        u.setVertexColor(colorA(255, 255, 255, 0))
        u.setPathing(false)
        u.pause()
        doingRoll = true
        let duration = 3.0
        let target = u.getPos().polarOffset(u.getFacingAngle(), 500)
        let tickTime = .05
        let numTicks = duration / tickTime
        let vecMovement = (target - u.getPos()).op_div(numTicks)
        let ef = addEffect(Units.grizzlyBear, u.getPos3Real() + vec3(0,0,100))
        ef.setYaw(vecMovement.getAngle().radians())
        ef.setScale(1.5)
        
        getTimer().doPeriodicallyTimed(.05, duration) (CallbackCounted cb) ->
            if(cb.isLast())
                u.unpause()
                u.setVertexColor(colorA(255, 255, 255, 255))
                doingRoll = false
                ef.setPos(vec3(0,0,0))
                u.setPathing(true)
                ef.destr()
            else
                u.setXY(u.getPos() + vecMovement)
                ef.setPos(u.getPos())
                ef.setRoll(getElapsedGameTime() * PI2 * 2)
